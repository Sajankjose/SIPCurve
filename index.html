<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SIP Curve Challenge – Full Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: #0b1f24;
      color: #f5f5f5;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .wrapper {
      display: flex;
      flex: 1;
      flex-direction: column;
      padding: 16px;
      gap: 16px;
    }

    @media (min-width: 900px) {
      .wrapper {
        flex-direction: row;
      }
    }

    .sidebar {
      background: #102a32;
      border-radius: 12px;
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 360px;
    }

    .sidebar h1 {
      font-size: 1.3rem;
      margin-bottom: 4px;
    }

    .sidebar p {
      font-size: 0.9rem;
      line-height: 1.4;
      color: #d3e0e5;
    }

    .metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 8px;
    }

    .metric-card {
      flex: 1 1 120px;
      background: #173641;
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 0.8rem;
    }

    .metric-label {
      opacity: 0.7;
      margin-bottom: 4px;
    }

    .metric-value {
      font-weight: 600;
      font-size: 0.95rem;
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: #123943;
      color: #9ce8ff;
      gap: 6px;
      margin-top: 6px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #3bd88f;
    }

    .btn-row {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 8px 16px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
    }

    .btn-primary {
      background: #00b894;
      color: #041013;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0, 184, 148, 0.35);
    }

    .btn-secondary {
      background: #203a43;
      color: #cfe4ea;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    button:not(:disabled):active {
      transform: translateY(1px);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }

    .canvas-panel {
      flex: 1;
      background: #102027;
      border-radius: 12px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .canvas-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
      flex-wrap: wrap;
    }

    .canvas-header span.label {
      opacity: 0.8;
    }

    .timer {
      font-weight: 600;
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .canvas-header-right {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .canvas-container {
      position: relative;
      flex: 1;
      background: radial-gradient(circle at top left, #173641, #07171c);
      border-radius: 10px;
      padding: 8px;
      overflow: hidden;
      min-height: 260px;
    }

    canvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: #020b10;
      display: block;
    }

    .axis-label {
      position: absolute;
      font-size: 0.65rem;
      color: #88a1a8;
      opacity: 0.8;
      pointer-events: none;
    }

    .axis-label.x-axis {
      bottom: 4px;
      left: 50%;
      transform: translateX(-50%);
    }

    .axis-label.y-axis {
      top: 50%;
      left: 8px;
      transform: translateY(-50%) rotate(-90deg);
      transform-origin: left center;
    }

    .toast {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: rgba(220, 53, 69, 0.95);
      color: #fff;
      padding: 10px 16px;
      border-radius: 999px;
      font-size: 0.8rem;
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      z-index: 999;
      white-space: nowrap;
    }

    .toast.show {
      opacity: 1;
      pointer-events: auto;
    }

    .results {
      font-size: 0.8rem;
      margin-top: 6px;
      color: #c6dde4;
    }

    .results strong {
      color: #3bd88f;
    }

    .hint {
      font-size: 0.75rem;
      opacity: 0.7;
      margin-top: 4px;
    }

    /* SUMMARY SCREEN STYLES */

    .summary-screen {
      margin: 16px;
      margin-top: 0;
      background: #08151b;
      border-radius: 12px;
      padding: 16px;
      border: 1px solid #15323b;
    }

    .summary-screen.hidden {
      display: none;
    }

    .summary-inner {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    @media (min-width: 960px) {
      .summary-inner {
        flex-direction: row;
      }
    }

    .summary-graphs {
      flex: 1.3;
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .graph-card {
      background: #102027;
      border-radius: 10px;
      padding: 10px 12px;
    }

    .graph-header h3 {
      font-size: 0.95rem;
      margin-bottom: 2px;
    }

    .graph-subtitle {
      font-size: 0.75rem;
      color: #a9c4cf;
    }

    .graph-body {
      margin-top: 8px;
      background: radial-gradient(circle at top left, #173641, #020b10);
      border-radius: 8px;
      padding: 6px;
    }

    .summary-canvas {
      width: 100%;
      height: 180px;
      display: block;
      border-radius: 6px;
      background: #02070b;
    }

    .axis-caption {
      display: flex;
      justify-content: space-between;
      font-size: 0.7rem;
      color: #7fa3b0;
      margin-top: 4px;
    }

    .fund-label {
      margin-top: 6px;
      font-size: 0.8rem;
      color: #c6dde4;
    }

    .fund-name {
      font-weight: 600;
    }

    .fund-period {
      font-size: 0.75rem;
      opacity: 0.8;
    }

    .summary-info {
      flex: 1;
      background: #0e2026;
      border-radius: 10px;
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .summary-info h2 {
      font-size: 1.05rem;
      margin-bottom: 4px;
    }

    .summary-metrics {
      border-radius: 8px;
      background: #132b33;
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .metric-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
    }

    .metric-label {
      color: #a4bec8;
    }

    .metric-value {
      font-weight: 600;
      color: #e3f6ff;
    }

    .explanation-block h4 {
      font-size: 0.85rem;
      margin-bottom: 2px;
    }

    .explanation-block p {
      font-size: 0.78rem;
      color: #c6dde4;
      line-height: 1.4;
    }

    .cta-block {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .cta-copy {
      font-size: 0.8rem;
      color: #e5f3f8;
    }

    .summary-info .btn-primary,
    .summary-info .btn-secondary {
      width: 100%;
      text-align: center;
    }

    .disclaimer-text {
      margin-top: 4px;
      font-size: 0.7rem;
      color: #8ea4ad;
      line-height: 1.4;
    }
  </style>
</head>

<body>
  <div class="wrapper">
    <!-- LEFT PANEL -->
    <aside class="sidebar">
      <h1>SIP Curve Challenge</h1>
      <p>
        Click & hold at Month 1 and draw your market up to Month 60.
        Every month, <strong>₹10,000</strong> is invested via SIP.
        If you release early, it simulates a SIP debit failure – a red blinking dot marks that point.
        Maximum <strong>3 stops</strong> allowed.
      </p>

      <div class="status-pill">
        <span class="status-dot"></span>
        <span id="statusText">Idle – press Start</span>
      </div>

      <div class="metrics">
        <div class="metric-card">
          <div class="metric-label">Current Month</div>
          <div class="metric-value" id="currentMonthValue">0 / 60</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Invested so far</div>
          <div class="metric-value" id="totalInvested">₹0</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Live estimate</div>
          <div class="metric-value" id="liveCorpus">₹0</div>
        </div>
      </div>

      <div class="btn-row">
        <button id="startBtn" class="btn-primary">Start Game</button>
        <button id="resetBtn" class="btn-secondary" disabled>Reset</button>
      </div>

      <div class="results">
        Final corpus: <strong id="finalCorpusValue">–</strong><br />
        SIP interruptions: <strong id="sipFailuresCount">0</strong><br />
        <span class="hint">
          (Tech note: real SIP + NAV logic can replace the stub in
          <code>computeResults()</code> and <code>computeLiveCorpus()</code>.)
        </span>
      </div>
    </aside>

    <!-- RIGHT PANEL: Main Game Canvas -->
    <main class="canvas-panel">
      <div class="canvas-header">
        <div>
          <span class="label">Mode:</span> Continuous SIP (don’t lift the pointer)
        </div>
        <div class="canvas-header-right">
          <div>
            <span class="label">Time left:</span>
            <span class="timer" id="timerDisplay">60s</span>
          </div>
          <div>
            <span class="label">Month:</span>
            <span id="currentMonthHeader">0 / 60</span>
          </div>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="sipCanvas"></canvas>
        <div class="axis-label x-axis">Months →</div>
        <div class="axis-label y-axis">NAV / Market Level</div>
      </div>

      <div class="hint">
        Desktop: click & hold at the left edge and drag to the right.  
        Mobile / tablet: long-press & drag.  
        Lifting early shows a blinking red dot (SIP failure).  
        You can resume from that point, but you cannot draw backwards in time.  
        Maximum 3 SIP failures allowed.
      </div>
    </main>
  </div>

  <!-- SUMMARY SCREEN -->
  <section id="summaryScreen" class="summary-screen hidden">
    <div class="summary-inner">
      <!-- LEFT: GRAPHS -->
      <div class="summary-graphs">
        <!-- Your curve -->
        <div class="graph-card">
          <div class="graph-header">
            <h3>Your SIP Curve</h3>
            <p class="graph-subtitle">
              How your drawn market behaved over 60 months.
            </p>
          </div>
          <div class="graph-body">
            <canvas id="playerCurveSummary" class="summary-canvas"></canvas>
            <div class="axis-caption">
              <span>Month 1</span>
              <span>Month 60</span>
            </div>
          </div>
        </div>

        <!-- Resembling fund -->
        <div class="graph-card">
          <div class="graph-header">
            <h3>Similar Fund Journey (Illustrative)</h3>
            <p class="graph-subtitle" id="fundMetaText">
              Based on your curve, this 60-month journey looks similar.
            </p>
          </div>
          <div class="graph-body">
            <canvas id="fundCurveSummary" class="summary-canvas"></canvas>
            <div class="axis-caption">
              <span id="fundStartLabel">Start</span>
              <span id="fundEndLabel">End</span>
            </div>
          </div>
          <div class="fund-label">
            <div class="fund-name" id="fundName">Illustrative Large Cap Curve</div>
            <div class="fund-period" id="fundPeriod">
              Period: Jan 2018 – Dec 2022 (example)
            </div>
          </div>
        </div>
      </div>

      <!-- RIGHT: NUMBERS + EXPLANATION -->
      <aside class="summary-info">
        <h2>What Your Curve is Telling You</h2>

        <div class="summary-metrics">
          <div class="metric-row">
            <span class="metric-label">Total invested via SIP</span>
            <span class="metric-value" id="sumTotalInvested">₹0</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Final corpus from your curve</span>
            <span class="metric-value" id="sumFinalCorpus">₹0</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Ideal corpus (no SIP breaks)</span>
            <span class="metric-value" id="sumIdealCorpus">₹0</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">SIP interruptions</span>
            <span class="metric-value" id="sumInterruptions">0</span>
          </div>
        </div>

        <div class="explanation-block">
          <h4>Your investing behaviour in this game</h4>
          <p id="behaviourText">
            You stayed invested through most of the ups and downs, but
            a few SIP interruptions reduced the power of compounding.
          </p>
        </div>

        <div class="explanation-block">
          <h4>What the similar journey shows</h4>
          <p id="fundInsightText">
            This illustrative 60-month path has a pattern similar to your
            drawing — periods of dips, recoveries, and stretches of growth.
            Investors who continued their SIPs through the dips benefited
            when the market recovered.
          </p>
        </div>

        <div class="cta-block">
          <p class="cta-copy">
            In real life, you can’t draw the market.  
            But you can choose to stay disciplined with your SIP.
          </p>
          <button id="talkToExpertBtn" class="btn-primary">
            Talk to a Geojit expert
          </button>
          <button id="sendMyReportBtn" class="btn-secondary">
            Send this result to my email / WhatsApp
          </button>
        </div>

        <p class="disclaimer-text">
          This journey is shown only as an illustration based on curve shape.
          It is <strong>not</strong> an investment recommendation. Please read
          all related documents carefully before investing.
        </p>
      </aside>
    </div>
  </section>

  <div class="toast" id="toast">SIP debit failed – pointer lifted early!</div>

  <script>
    // BASIC CONFIG
    const TOTAL_MONTHS = 60;
    const MONTHLY_SIP = 10000;
    const GAME_DURATION_SECONDS = 60;
    const MAX_INTERRUPTIONS = 3;

    // DOM ELEMENTS
    const canvas = document.getElementById("sipCanvas");
    const ctx = canvas.getContext("2d");
    const timerDisplay = document.getElementById("timerDisplay");
    const startBtn = document.getElementById("startBtn");
    const resetBtn = document.getElementById("resetBtn");
    const toast = document.getElementById("toast");
    const statusText = document.getElementById("statusText");
    const totalInvestedEl = document.getElementById("totalInvested");
    const currentMonthValueEl = document.getElementById("currentMonthValue");
    const currentMonthHeaderEl = document.getElementById("currentMonthHeader");
    const liveCorpusEl = document.getElementById("liveCorpus");
    const finalCorpusEl = document.getElementById("finalCorpusValue");
    const sipFailuresCountEl = document.getElementById("sipFailuresCount");
    const summaryScreenEl = document.getElementById("summaryScreen");

    // Summary elements
    const sumTotalInvestedEl = document.getElementById("sumTotalInvested");
    const sumFinalCorpusEl = document.getElementById("sumFinalCorpus");
    const sumIdealCorpusEl = document.getElementById("sumIdealCorpus");
    const sumInterruptionsEl = document.getElementById("sumInterruptions");
    const behaviourTextEl = document.getElementById("behaviourText");

    // STATE
    let isDrawing = false;
    let gameActive = false;
    let points = []; // {x, y, month}
    let timerInterval = null;
    let remainingTime = GAME_DURATION_SECONDS;
    let canvasRect = null;
    let xMin, xMax, yMin, yMax;
    let sipFailures = 0;
    let lastPoint = null;

    // Blinking red dot state
    let interruptionPoints = []; // {x, y}
    let blinkOn = true;
    let blinkInterval = null;

    // Summary series
    let summaryPlayerSeries = null; // 60 values, 0..1
    let summaryFundSeries = null;   // 60 values, 0..1

    // RESIZE MAIN CANVAS
    function resizeCanvas() {
      const parent = canvas.parentElement;
      const bounds = parent.getBoundingClientRect();
      const ratio = window.devicePixelRatio || 1;

      canvas.width = bounds.width * ratio;
      canvas.height = bounds.height * ratio;

      canvas.style.width = bounds.width + "px";
      canvas.style.height = bounds.height + "px";

      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);

      canvasRect = canvas.getBoundingClientRect();

      // Define drawing bounds with some padding
      xMin = 40;
      xMax = bounds.width - 20;
      yMin = 20;
      yMax = bounds.height - 30;

      drawBaseGrid();
      if (points.length > 0) {
        redrawCurve();
      }

      // If summary exists, redraw summary graphs on resize
      if (summaryPlayerSeries && summaryFundSeries && !summaryScreenEl.classList.contains("hidden")) {
        drawSummaryGraphs();
      }
    }

    window.addEventListener("resize", resizeCanvas);
    window.addEventListener("load", resizeCanvas);

    // DRAW GRID + AXES
    function drawBaseGrid() {
      if (!canvasRect) return;
      const width = canvasRect.width;
      const height = canvasRect.height;

      ctx.clearRect(0, 0, width, height);

      // Background
      const bgGrad = ctx.createLinearGradient(0, 0, width, height);
      bgGrad.addColorStop(0, "#021019");
      bgGrad.addColorStop(1, "#02070b");
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, width, height);

      ctx.save();
      ctx.strokeStyle = "#12313c";
      ctx.lineWidth = 1;

      // vertical grid (every 10 months)
      for (let i = 0; i <= 6; i++) {
        const x = xMin + ((xMax - xMin) * i) / 6;
        ctx.beginPath();
        ctx.moveTo(x, yMin);
        ctx.lineTo(x, yMax);
        ctx.stroke();
      }

      // horizontal grid lines
      for (let i = 0; i <= 4; i++) {
        const y = yMin + ((yMax - yMin) * i) / 4;
        ctx.beginPath();
        ctx.moveTo(xMin, y);
        ctx.lineTo(xMax, y);
        ctx.stroke();
      }

      // Axes
      ctx.strokeStyle = "#1f4c5b";
      ctx.lineWidth = 2;

      // X-axis
      ctx.beginPath();
      ctx.moveTo(xMin, yMax);
      ctx.lineTo(xMax, yMax);
      ctx.stroke();

      // Y-axis
      ctx.beginPath();
      ctx.moveTo(xMin, yMin);
      ctx.lineTo(xMin, yMax);
      ctx.stroke();

      // Month labels
      ctx.fillStyle = "#7fa3b0";
      ctx.font = "10px system-ui";
      for (let m = 0; m <= TOTAL_MONTHS; m += 10) {
        const x = xMin + ((xMax - xMin) * m) / TOTAL_MONTHS;
        ctx.fillText(m.toString(), x - 6, yMax + 12);
      }

      ctx.restore();
    }

    // HELPERS
    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function positionToMonth(x) {
      const ratio = (x - xMin) / (xMax - xMin);
      const month = 1 + ratio * (TOTAL_MONTHS - 1);
      return clamp(Math.round(month), 1, TOTAL_MONTHS);
    }

    function formatNumber(num) {
      return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }

    function updateLiveMetrics() {
      const currentMonth = lastPoint ? lastPoint.month : 0;
      currentMonthValueEl.textContent = `${currentMonth} / ${TOTAL_MONTHS}`;
      currentMonthHeaderEl.textContent = `${currentMonth} / ${TOTAL_MONTHS}`;

      const invested = currentMonth * MONTHLY_SIP;
      totalInvestedEl.textContent = "₹" + formatNumber(invested);

      const live = computeLiveCorpus();
      liveCorpusEl.textContent = "₹" + formatNumber(Math.round(live));
    }

    // DRAWING LOGIC
    function startDrawing(clientX, clientY) {
      if (!gameActive || !canvasRect) return;

      const x = clamp(clientX - canvasRect.left, xMin, xMax);
      const y = clamp(clientY - canvasRect.top, yMin, yMax);

      // First time: must start near Month 1
      if (points.length === 0) {
        if (x > xMin + 15) return;
        const month = positionToMonth(xMin);
        const startPoint = { x: xMin, y, month };
        points.push(startPoint);
        lastPoint = startPoint;
        isDrawing = true;
        statusText.textContent = "Drawing – keep holding until Month 60";
        redrawCurve();
        updateLiveMetrics();
        return;
      }

      // Resume after interruption:
      const tolerance = 8;
      const prev = lastPoint;
      if (x + tolerance < prev.x) {
        showToast("You cannot draw backwards in time.");
        return;
      }

      const startX = Math.max(x, prev.x);
      const month = positionToMonth(startX);
      const resumedPoint = { x: startX, y, month };
      points.push(resumedPoint);
      lastPoint = resumedPoint;
      isDrawing = true;
      redrawCurve();
      updateLiveMetrics();
    }

    function continueDrawing(clientX, clientY) {
      if (!isDrawing || !gameActive || !canvasRect) return;

      const rawX = clientX - canvasRect.left;
      const rawY = clientY - canvasRect.top;
      const x = clamp(rawX, xMin, xMax);
      const y = clamp(rawY, yMin, yMax);

      if (lastPoint && x < lastPoint.x) return;

      const month = positionToMonth(x);
      const newPoint = { x, y, month };
      points.push(newPoint);
      lastPoint = newPoint;
      redrawCurve();
      updateLiveMetrics();

      if (month >= TOTAL_MONTHS && gameActive) {
        endGame();
      }
    }

    function stopDrawing() {
      if (!isDrawing) return;
      isDrawing = false;

      if (!lastPoint || !gameActive) return;

      const finalMonthReached = lastPoint.month >= TOTAL_MONTHS - 1;
      if (!finalMonthReached) {
        sipFailures++;
        sipFailuresCountEl.textContent = sipFailures.toString();

        if (interruptionPoints.length < MAX_INTERRUPTIONS) {
          interruptionPoints.push({ x: lastPoint.x, y: lastPoint.y });
          showToast("SIP debit failed – pointer lifted early!");
          statusText.textContent = "SIP interrupted – you can resume from this point.";
          redrawCurve();
        } else {
          showToast("Maximum SIP interruptions reached – game over.");
          endGame();
        }
      }
    }

    // REDRAW CURVE + BLINKING DOTS
    function redrawCurve() {
      drawBaseGrid();

      if (points.length >= 2) {
        ctx.save();
        ctx.strokeStyle = "#3bd88f";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();
        ctx.restore();
      }

      // Blinking red circles at interruptions
      if (interruptionPoints.length > 0 && blinkOn) {
        ctx.save();
        ctx.strokeStyle = "#ff4b5c";
        ctx.fillStyle = "rgba(255, 75, 92, 0.2)";
        ctx.lineWidth = 2;

        interruptionPoints.forEach((pt) => {
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          ctx.beginPath();
          ctx.fillStyle = "#ff4b5c";
          ctx.arc(pt.x, pt.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.restore();
      }
    }

    // TIMER
    function startTimer() {
      remainingTime = GAME_DURATION_SECONDS;
      timerDisplay.textContent = remainingTime + "s";

      timerInterval = setInterval(() => {
        remainingTime--;
        timerDisplay.textContent = remainingTime + "s";

        if (remainingTime <= 0) {
          endGame();
        }
      }, 1000);
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    // BLINKING
    function startBlinking() {
      if (blinkInterval) clearInterval(blinkInterval);
      blinkOn = true;
      blinkInterval = setInterval(() => {
        blinkOn = !blinkOn;
        redrawCurve();
      }, 500);
    }

    function stopBlinking() {
      if (blinkInterval) {
        clearInterval(blinkInterval);
        blinkInterval = null;
      }
    }

    // GAME CONTROL
    function startGame() {
      gameActive = true;
      points = [];
      lastPoint = null;
      sipFailures = 0;
      interruptionPoints = [];
      sipFailuresCountEl.textContent = "0";
      finalCorpusEl.textContent = "–";
      statusText.textContent = "Drawing – start at Month 1 and keep going";
      startBtn.disabled = true;
      resetBtn.disabled = false;
      remainingTime = GAME_DURATION_SECONDS;
      timerDisplay.textContent = remainingTime + "s";
      currentMonthValueEl.textContent = `0 / ${TOTAL_MONTHS}`;
      currentMonthHeaderEl.textContent = `0 / ${TOTAL_MONTHS}`;
      totalInvestedEl.textContent = "₹0";
      liveCorpusEl.textContent = "₹0";

      summaryScreenEl.classList.add("hidden"); // hide old summary
      summaryPlayerSeries = null;
      summaryFundSeries = null;

      drawBaseGrid();
      startTimer();
      startBlinking();
    }

    function endGame() {
      if (!gameActive) return;
      gameActive = false;
      isDrawing = false;
      stopTimer();
      timerDisplay.textContent = "0s";
      statusText.textContent = "Game over – see your result below";

      computeResults();
      startBtn.disabled = false;
      // keep blinking so red dots stay visible
    }

    function resetGame() {
      stopTimer();
      stopBlinking();
      gameActive = false;
      isDrawing = false;
      points = [];
      lastPoint = null;
      sipFailures = 0;
      interruptionPoints = [];
      sipFailuresCountEl.textContent = "0";
      remainingTime = GAME_DURATION_SECONDS;
      timerDisplay.textContent = remainingTime + "s";
      statusText.textContent = "Idle – press Start";
      startBtn.disabled = false;
      resetBtn.disabled = true;
      finalCorpusEl.textContent = "–";
      currentMonthValueEl.textContent = `0 / ${TOTAL_MONTHS}`;
      currentMonthHeaderEl.textContent = `0 / ${TOTAL_MONTHS}`;
      totalInvestedEl.textContent = "₹0";
      liveCorpusEl.textContent = "₹0";

      summaryScreenEl.classList.add("hidden");
      summaryPlayerSeries = null;
      summaryFundSeries = null;

      drawBaseGrid();
    }

    // LIVE + FINAL CORPUS (STUB)
    function computeLiveCorpus() {
      if (!lastPoint || points.length === 0) return 0;

      let sumNorm = 0;
      for (const p of points) {
        const normalized = 1 - (p.y - yMin) / (yMax - yMin); // 0..1
        sumNorm += normalized;
      }
      const avgNorm = sumNorm / points.length;

      const currentMonth = lastPoint.month;
      const baseInvested = currentMonth * MONTHLY_SIP;
      const growthFactor = 1 + avgNorm * 1.4;

      const penaltyFactor = 1 - Math.min(sipFailures * 0.05, 0.5);
      const liveValue = Math.max(0, baseInvested * growthFactor * penaltyFactor);

      return liveValue;
    }

    function computeResults() {
      if (!lastPoint || points.length === 0) {
        finalCorpusEl.textContent = "No curve drawn";
        return;
      }

      const live = computeLiveCorpus();
      finalCorpusEl.textContent = "₹" + formatNumber(Math.round(live));

      // Ideal corpus (no SIP breaks) – same logic but penaltyFactor=1
      let sumNorm = 0;
      for (const p of points) {
        const normalized = 1 - (p.y - yMin) / (yMax - yMin);
        sumNorm += normalized;
      }
      const avgNorm = sumNorm / points.length;
      const baseInvested = TOTAL_MONTHS * MONTHLY_SIP;
      const idealGrowthFactor = 1 + avgNorm * 1.4;
      const idealCorpus = baseInvested * idealGrowthFactor;

      // Build summary series from points
      buildSummarySeriesFromPoints();
      // Show summary with numbers + graphs
      showSummary(live, idealCorpus);
    }

    // Build 60-month series from drawn points (0..1 normalized)
    function buildSummarySeriesFromPoints() {
      if (points.length === 0) return;

      const series = new Array(TOTAL_MONTHS).fill(0.5); // default mid

      let lastVal = 0.5;
      for (let m = 1; m <= TOTAL_MONTHS; m++) {
        const ptsForMonth = points.filter((p) => p.month === m);
        if (ptsForMonth.length > 0) {
          const p = ptsForMonth[ptsForMonth.length - 1];
          const normalized = 1 - (p.y - yMin) / (yMax - yMin);
          lastVal = clamp(normalized, 0, 1);
        }
        series[m - 1] = lastVal;
      }

      summaryPlayerSeries = series;

      // Mock "fund" series: blend your curve with a smooth upward line
      const fundSeries = [];
      for (let i = 0; i < TOTAL_MONTHS; i++) {
        const t = i / (TOTAL_MONTHS - 1);
        const idealUp = 0.2 + 0.6 * t; // gentle slope 0.2->0.8
        const blended = 0.4 * series[i] + 0.6 * idealUp;
        fundSeries.push(clamp(blended, 0, 1));
      }
      summaryFundSeries = fundSeries;
    }

    // SUMMARY SCREEN DISPLAY
    function showSummary(liveCorpus, idealCorpus) {
      const totalInvested = TOTAL_MONTHS * MONTHLY_SIP;

      sumTotalInvestedEl.textContent = "₹" + formatNumber(totalInvested);
      sumFinalCorpusEl.textContent = "₹" + formatNumber(Math.round(liveCorpus));
      sumIdealCorpusEl.textContent = "₹" + formatNumber(Math.round(idealCorpus));
      sumInterruptionsEl.textContent = sipFailures.toString();

      if (sipFailures === 0) {
        behaviourTextEl.textContent =
          "You stayed invested for the full 60 months without any SIP breaks. This is exactly how compounding works best over time.";
      } else if (sipFailures <= 2) {
        behaviourTextEl.textContent =
          "You had a couple of SIP interruptions, but you still stayed invested for most of the journey. Fewer breaks would give compounding even more power.";
      } else {
        behaviourTextEl.textContent =
          "Frequent SIP interruptions reduced the benefit of compounding. In real investing, staying disciplined through ups and downs can make a large difference.";
      }

      summaryScreenEl.classList.remove("hidden");
      drawSummaryGraphs();
    }

    // Draw series into summary canvases
    function drawSummaryGraphs() {
      drawSeriesOnCanvas("playerCurveSummary", summaryPlayerSeries, "#3bd88f");
      drawSeriesOnCanvas("fundCurveSummary", summaryFundSeries, "#4da3ff");
    }

    function drawSeriesOnCanvas(canvasId, series, strokeStyle) {
      const canvas = document.getElementById(canvasId);
      if (!canvas || !series || series.length < 2) return;

      const parent = canvas.parentElement;
      const rect = parent.getBoundingClientRect();
      const ratio = window.devicePixelRatio || 1;
      const width = rect.width;
      const height = 180;

      canvas.width = width * ratio;
      canvas.height = height * ratio;
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";

      const cctx = canvas.getContext("2d");
      cctx.setTransform(ratio, 0, 0, ratio, 0, 0);

      // Background
      cctx.fillStyle = "#02070b";
      cctx.fillRect(0, 0, width, height);

      // Optional faint grid
      cctx.strokeStyle = "#12242c";
      cctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = (height * i) / 4;
        cctx.beginPath();
        cctx.moveTo(0, y);
        cctx.lineTo(width, y);
        cctx.stroke();
      }

      const leftPad = 20;
      const rightPad = 10;
      const topPad = 10;
      const bottomPad = 16;
      const usableW = width - leftPad - rightPad;
      const usableH = height - topPad - bottomPad;

      cctx.strokeStyle = strokeStyle;
      cctx.lineWidth = 2;
      cctx.beginPath();

      series.forEach((value, idx) => {
        const x = leftPad + (usableW * idx) / (series.length - 1);
        const val = clamp(value, 0, 1);
        const y = topPad + (1 - val) * usableH;
        if (idx === 0) cctx.moveTo(x, y);
        else cctx.lineTo(x, y);
      });
      cctx.stroke();
    }

    // TOAST
    function showToast(message) {
      toast.textContent = message;
      toast.classList.add("show");
      setTimeout(() => {
        toast.classList.remove("show");
      }, 2000);
    }

    // EVENTS – MOUSE
    canvas.addEventListener("mousedown", (e) => {
      e.preventDefault();
      startDrawing(e.clientX, e.clientY);
    });

    canvas.addEventListener("mousemove", (e) => {
      e.preventDefault();
      continueDrawing(e.clientX, e.clientY);
    });

    window.addEventListener("mouseup", (e) => {
      stopDrawing();
    });

    // TOUCH
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      startDrawing(touch.clientX, touch.clientY);
    });

    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      continueDrawing(touch.clientX, touch.clientY);
    });

    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      stopDrawing();
    });

    // BUTTONS
    startBtn.addEventListener("click", startGame);
    resetBtn.addEventListener("click", resetGame);
  </script>
</body>
</html>
