<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SIP Curve Challenge â€“ Compounding Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: #0b1f24;
      color: #f5f5f5;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .wrapper {
      display: flex;
      flex: 1;
      flex-direction: column;
      padding: 16px;
      gap: 16px;
    }

    @media (min-width: 900px) {
      .wrapper {
        flex-direction: row;
      }
    }

    .sidebar {
      background: #102a32;
      border-radius: 12px;
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 380px;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .sidebar h1 {
      font-size: 1.3rem;
      margin-bottom: 4px;
    }

    .sidebar p {
      font-size: 0.9rem;
      line-height: 1.4;
      color: #d3e0e5;
    }

    .metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 8px;
    }

    .metric-card {
      flex: 1 1 140px;
      background: #173641;
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 0.8rem;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .metric-label {
      opacity: 0.7;
      margin-bottom: 4px;
    }

    .metric-value {
      font-weight: 600;
      font-size: 0.95rem;
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: #123943;
      color: #9ce8ff;
      gap: 6px;
      margin-top: 6px;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #3bd88f;
    }

    .btn-row {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 8px 16px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease, background 0.2s ease, color 0.2s ease;
    }

    .btn-primary {
      background: #00b894;
      color: #041013;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0, 184, 148, 0.35);
    }

    .btn-secondary {
      background: #203a43;
      color: #cfe4ea;
    }

    .tiny-btn {
      padding: 4px 8px;
      font-size: 0.7rem;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    button:not(:disabled):active {
      transform: translateY(1px);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }

    .canvas-panel {
      flex: 1;
      background: #102027;
      border-radius: 12px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .canvas-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
      flex-wrap: wrap;
    }

    .canvas-header span.label {
      opacity: 0.8;
    }

    .timer {
      font-weight: 600;
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .canvas-header-right {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .canvas-container {
      position: relative;
      flex: 1;
      background: radial-gradient(circle at top left, #173641, #07171c);
      border-radius: 10px;
      padding: 8px;
      overflow: hidden;
      min-height: 260px;
      transition: background 0.2s ease;
    }

    canvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: #020b10;
      display: block;
      touch-action: none; /* important for iPad */
    }

    .axis-label {
      position: absolute;
      font-size: 0.65rem;
      color: #88a1a8;
      opacity: 0.8;
      pointer-events: none;
    }

    .axis-label.x-axis {
      bottom: 4px;
      left: 50%;
      transform: translateX(-50%);
    }

    .axis-label.y-axis {
      top: 50%;
      left: 8px;
      transform: translateY(-50%) rotate(-90deg);
      transform-origin: left center;
    }

    .toast {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: rgba(220, 53, 69, 0.95);
      color: #fff;
      padding: 10px 16px;
      border-radius: 999px;
      font-size: 0.8rem;
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      z-index: 999;
      white-space: nowrap;
    }

    .toast.show {
      opacity: 1;
      pointer-events: auto;
    }

    .results {
      font-size: 0.8rem;
      margin-top: 6px;
      color: #c6dde4;
    }

    .results strong {
      color: #3bd88f;
    }

    .hint {
      font-size: 0.75rem;
      opacity: 0.7;
      margin-top: 4px;
    }

    /* SUMMARY SCREEN STYLES */

    .summary-screen {
      margin: 16px;
      margin-top: 0;
      background: #08151b;
      border-radius: 12px;
      padding: 16px;
      border: 1px solid #15323b;
      transition: background 0.2s ease, border-color 0.2s ease;
    }

    .summary-screen.hidden {
      display: none;
    }

    .summary-inner {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    @media (min-width: 960px) {
      .summary-inner {
        flex-direction: row;
      }
    }

    .summary-graphs {
      flex: 1.3;
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .graph-card {
      background: #102027;
      border-radius: 10px;
      padding: 10px 12px;
      transition: background 0.2s ease;
    }

    .graph-header h3 {
      font-size: 0.95rem;
      margin-bottom: 2px;
    }

    .graph-subtitle {
      font-size: 0.75rem;
      color: #a9c4cf;
    }

    .graph-body {
      margin-top: 8px;
      background: radial-gradient(circle at top left, #173641, #020b10);
      border-radius: 8px;
      padding: 6px;
      transition: background 0.2s ease;
    }

    .summary-canvas {
      width: 100%;
      height: 180px;
      display: block;
      border-radius: 6px;
      background: #02070b;
      touch-action: none;
    }

    .axis-caption {
      display: flex;
      justify-content: space-between;
      font-size: 0.7rem;
      color: #7fa3b0;
      margin-top: 4px;
    }

    .fund-label {
      margin-top: 6px;
      font-size: 0.8rem;
      color: #c6dde4;
    }

    .fund-name {
      font-weight: 600;
    }

    .fund-period {
      font-size: 0.75rem;
      opacity: 0.8;
    }

    .summary-info {
      flex: 1;
      background: #0e2026;
      border-radius: 10px;
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      transition: background 0.2s ease;
    }

    .summary-info h2 {
      font-size: 1.05rem;
      margin-bottom: 4px;
    }

    .summary-metrics {
      border-radius: 8px;
      background: #132b33;
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      transition: background 0.2s ease;
    }

    .metric-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
    }

    .metric-label {
      color: #a4bec8;
    }

    .metric-value {
      font-weight: 600;
      color: #e3f6ff;
    }

    .explanation-block h4 {
      font-size: 0.85rem;
      margin-bottom: 2px;
    }

    .explanation-block p {
      font-size: 0.78rem;
      color: #c6dde4;
      line-height: 1.4;
    }

    .cta-block {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .cta-copy {
      font-size: 0.8rem;
      color: #e5f3f8;
    }

    .summary-info .btn-primary,
    .summary-info .btn-secondary {
      width: 100%;
      text-align: center;
    }

    .disclaimer-text {
      margin-top: 4px;
      font-size: 0.7rem;
      color: #8ea4ad;
      line-height: 1.4;
    }

    /* Demo funds list */

    .demo-funds {
      margin-top: 6px;
      padding: 8px 10px;
      background: #10252d;
      border-radius: 8px;
      transition: background 0.2s ease;
    }

    .demo-funds h4 {
      font-size: 0.8rem;
      margin-bottom: 4px;
    }

    .demo-funds-note {
      font-size: 0.7rem;
      color: #8ea4ad;
      margin-bottom: 4px;
    }

    .demo-funds-list {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 3px;
      max-height: 160px;
      overflow-y: auto;
    }

    .demo-fund-item {
      display: flex;
      flex-direction: column;
      font-size: 0.74rem;
      padding: 4px 6px;
      border-radius: 4px;
      background: rgba(12, 42, 49, 0.7);
    }

    .demo-fund-name {
      font-weight: 600;
    }

    .demo-fund-meta {
      font-size: 0.7rem;
      color: #b7d0da;
    }

    /* ===== Conclusion Modal ===== */

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      backdrop-filter: blur(2px);
    }

    .modal-backdrop.hidden {
      display: none;
    }

    .conclusion-modal {
      background: #0f2229;
      border-radius: 14px;
      padding: 16px 18px;
      max-width: 420px;
      width: 92%;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
      border: 1px solid #1f3a44;
      transition: background 0.2s ease, border-color 0.2s ease;
    }

    .conclusion-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .conclusion-modal-title {
      font-size: 1rem;
      font-weight: 600;
    }

    .conclusion-modal-close {
      background: transparent;
      border: none;
      color: #9fb8c2;
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0 4px;
    }

    .conclusion-modal-body {
      font-size: 0.85rem;
      color: #d1e5ec;
      line-height: 1.5;
    }

    .conclusion-highlight {
      color: #3bd88f;
      font-weight: 600;
    }

    .conclusion-bullets {
      margin: 8px 0 10px;
      padding-left: 18px;
    }

    .conclusion-bullets li {
      margin-bottom: 4px;
    }

    .conclusion-note {
      font-size: 0.78rem;
      color: #9fb8c2;
      margin-top: 4px;
    }

    .conclusion-modal-footer {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: flex-end;
    }

    .conclusion-btn-secondary {
      background: #203a43;
      color: #cfe4ea;
      border-radius: 999px;
      padding: 8px 14px;
      border: none;
      font-size: 0.8rem;
      cursor: pointer;
    }

    .conclusion-btn-primary {
      background: #00b894;
      color: #041013;
      border-radius: 999px;
      padding: 8px 16px;
      border: none;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 184, 148, 0.35);
    }

    /* ===== LIGHT THEME OVERRIDES (IMPROVED READABILITY) ===== */

    body.light-theme {
      background: #f4f7fb;
      color: #122026;
    }

    body.light-theme .wrapper {
      background: #f4f7fb;
    }

    body.light-theme .sidebar {
      background: #ffffff;
      color: #122026;
    }

    body.light-theme .sidebar p {
      color: #1f333d;
    }

    body.light-theme .metric-card {
      background: #f0f4f8;
      color: #122026;
    }

    body.light-theme .metric-label {
      color: #50616d;
      opacity: 1;
    }

    body.light-theme .metric-value {
      color: #122026;
    }

    body.light-theme .status-pill {
      background: #e2f4ff;
      color: #0b2733;
    }

    body.light-theme .canvas-panel {
      background: #ffffff;
      color: #122026;
    }

    body.light-theme .results {
      color: #1e333d;
    }

    body.light-theme .hint {
      color: #4b5c68;
      opacity: 1;
    }

    body.light-theme .canvas-container {
      background: radial-gradient(circle at top left, #e4f0f7, #f5f8fb);
    }

    body.light-theme canvas {
      background: #ffffff;
    }

    body.light-theme .axis-label {
      color: #546574;
      opacity: 1;
    }

    body.light-theme .summary-screen {
      background: #ffffff;
      border-color: #d7dfeb;
    }

    body.light-theme .graph-card {
      background: #f7fafc;
    }

    body.light-theme .graph-header h3 {
      color: #122026;
    }

    body.light-theme .graph-subtitle {
      color: #4a5a66;
    }

    body.light-theme .graph-body {
      background: radial-gradient(circle at top left, #e4f1f7, #ffffff);
    }

    body.light-theme .axis-caption {
      color: #4a5a66;
    }

    body.light-theme .fund-label {
      color: #233544;
    }

    body.light-theme .summary-info {
      background: #f7fafc;
      color: #122026;
    }

    body.light-theme .summary-metrics {
      background: #edf2f7;
    }

    body.light-theme .summary-metrics .metric-label {
      color: #445563;
    }

    body.light-theme .summary-metrics .metric-value {
      color: #122026;
    }

    body.light-theme .explanation-block p {
      color: #233544;
    }

    body.light-theme .cta-copy {
      color: #233544;
    }

    body.light-theme .demo-funds {
      background: #edf4f9;
    }

    body.light-theme .demo-funds-note {
      color: #4a5a66;
    }

    body.light-theme .demo-fund-item {
      background: #dde9f4;
      color: #122026;
    }

    body.light-theme .demo-fund-meta {
      color: #4a5a66;
    }

    body.light-theme .disclaimer-text {
      color: #5f7581;
    }

    body.light-theme .conclusion-modal {
      background: #ffffff;
      border-color: #d5e2ec;
      color: #122026;
    }

    body.light-theme .conclusion-modal-body {
      color: #1e333d;
    }

    body.light-theme .conclusion-note {
      color: #5f7581;
    }
  </style>
</head>

<body>
  <div class="wrapper">
    <!-- LEFT PANEL -->
    <aside class="sidebar">
      <h1>SIP Curve Challenge</h1>
      <p>
        You invest <strong>â‚¹10,000</strong> every month for 60 months (SIP).
        Draw how you think the market will move in this <strong>30-second game</strong>.  
        When the curve goes <strong>down</strong>, NAV falls below 100 and your SIP buys more units.  
        When it goes <strong>up</strong>, those accumulated units grow â€“ thatâ€™s the power of compounding.
      </p>

      <div class="status-pill">
        <span class="status-dot"></span>
        <span id="statusText">Idle â€“ press Start</span>
      </div>

      <div class="metrics">
        <div class="metric-card">
          <div class="metric-label">Current Month</div>
          <div class="metric-value" id="currentMonthValue">0 / 60</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Invested so far</div>
          <div class="metric-value" id="totalInvested">â‚¹0</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Current NAV index</div>
          <div class="metric-value" id="currentNavValue">100.0</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Live corpus</div>
          <div class="metric-value" id="liveCorpus">â‚¹0</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">XIRR (your curve)</div>
          <div class="metric-value" id="xirrValue">â€“</div>
        </div>
      </div>

      <div class="btn-row">
        <button id="startBtn" class="btn-primary">Start Game</button>
        <button id="resetBtn" class="btn-secondary" disabled>Reset</button>
      </div>

      <div class="results">
        Final corpus: <strong id="finalCorpusValue">â€“</strong><br />
        SIP interruptions: <strong id="sipFailuresCount">0</strong><br />
        <span class="hint">
          NAV starts at <strong>100</strong>. Dips = more units, rallies = growth on those units.
        </span>
      </div>
    </aside>

    <!-- RIGHT PANEL: Main Game Canvas -->
    <main class="canvas-panel">
      <div class="canvas-header">
        <div>
          <span class="label">Mode:</span> Time-paced SIP (30 seconds = 60 months)
        </div>
        <div class="canvas-header-right">
          <div>
            <span class="label">Time left:</span>
            <span class="timer" id="timerDisplay">30s</span>
          </div>
          <div>
            <span class="label">Month:</span>
            <span id="currentMonthHeader">0 / 60</span>
          </div>
          <button id="soundToggleBtn" class="btn-secondary tiny-btn">ðŸ”Š Sound: On</button>
          <button id="themeToggleBtn" class="btn-secondary tiny-btn">ðŸŒ™ Dark</button>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="sipCanvas"></canvas>
        <div class="axis-label x-axis">Months â†’</div>
        <div class="axis-label y-axis">NAV / Market Level</div>
      </div>

      <div class="hint">
        Laptop / iPad: press & hold and control the height of the line.  
        The line moves forward in time automatically (~2 months per second).  
        Lifting early shows a blinking red dot (SIP failure).  
        Maximum 3 SIP failures allowed.
      </div>
    </main>
  </div>

  <!-- SUMMARY SCREEN -->
  <section id="summaryScreen" class="summary-screen hidden">
    <div class="summary-inner">
      <!-- LEFT: GRAPHS -->
      <div class="summary-graphs">
        <!-- Your curve -->
        <div class="graph-card">
          <div class="graph-header">
            <h3>Your SIP Curve</h3>
            <p class="graph-subtitle">
              NAV index starts at 100. Your drawing decides the ups & downs.
            </p>
          </div>
          <div class="graph-body">
            <canvas id="playerCurveSummary" class="summary-canvas"></canvas>
            <div class="axis-caption">
              <span>Month 1 (NAV 100)</span>
              <span>Month 60</span>
            </div>
          </div>
        </div>

        <!-- Resembling fund -->
        <div class="graph-card">
          <div class="graph-header">
            <h3>Similar Fund Journey (Illustrative)</h3>
            <p class="graph-subtitle" id="fundMetaText">
              A demo 60-month NAV path that looks similar to your curve.
            </p>
          </div>
          <div class="graph-body">
            <canvas id="fundCurveSummary" class="summary-canvas"></canvas>
            <div class="axis-caption">
              <span id="fundStartLabel">Month 1 (Index 100)</span>
              <span id="fundEndLabel">Month 60</span>
            </div>
          </div>
          <div class="fund-label">
            <div class="fund-name" id="fundName">Illustrative Large Cap Curve</div>
            <div class="fund-period" id="fundPeriod">
              Period: Jan 2018 â€“ Dec 2022 (example data)
            </div>
          </div>
        </div>
      </div>

      <!-- RIGHT: NUMBERS + EXPLANATION + DEMO FUNDS -->
      <aside class="summary-info">
        <h2>What Your Curve is Telling You</h2>

        <div class="summary-metrics">
          <div class="metric-row">
            <span class="metric-label">Total invested via SIP</span>
            <span class="metric-value" id="sumTotalInvested">â‚¹0</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Final corpus from your curve</span>
            <span class="metric-value" id="sumFinalCorpus">â‚¹0</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Ideal corpus (no SIP breaks)</span>
            <span class="metric-value" id="sumIdealCorpus">â‚¹0</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">SIP interruptions</span>
            <span class="metric-value" id="sumInterruptions">0</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">XIRR (annualised)</span>
            <span class="metric-value" id="sumXirr">â€“</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Units accumulated</span>
            <span class="metric-value" id="sumUnits">â€“</span>
          </div>
          <div class="metric-row">
            <span class="metric-label">Average buy NAV</span>
            <span class="metric-value" id="sumAvgNav">â€“</span>
          </div>
        </div>

        <div class="explanation-block">
          <h4>Your investing behaviour in this game</h4>
          <p id="behaviourText">
            You experienced both dips and rallies. In dips (NAV below 100),
            your SIP bought more units. When the NAV later moved above 100,
            those extra units worked harder for you â€“ thatâ€™s compounding in action.
          </p>
        </div>

        <div class="explanation-block">
          <h4>What the similar journey shows</h4>
          <p id="fundInsightText">
            This illustrative 60-month NAV path behaves a bit like what you drew â€“
            periods of correction followed by recoveries. Investors who kept their
            SIPs running through the dips benefited when the NAV moved up again.
          </p>
        </div>

        <div class="cta-block">
          <p class="cta-copy">
            In real life, you canâ€™t control the NAV path.  
            But you can control your discipline â€“ staying invested with SIP.
          </p>
          <button id="talkToExpertBtn" class="btn-primary">
            Talk to a Geojit expert
          </button>
          <button id="whatsappShareBtn" class="btn-secondary">
            Share on WhatsApp
          </button>
          <button id="emailShareBtn" class="btn-secondary">
            Share via Email
          </button>
        </div>

        <div class="demo-funds">
          <h4>Sample funds (demo only)</h4>
          <p class="demo-funds-note">
            Static placeholder data to show how real fund journeys could be displayed.
          </p>
          <ul id="demoFundsList" class="demo-funds-list"></ul>
        </div>

        <p class="disclaimer-text">
          All fund names and figures shown here are illustrative for demo purposes only.
          This is <strong>not</strong> an investment recommendation.
          Please read all scheme related documents carefully before investing.
        </p>
      </aside>
    </div>
  </section>

  <!-- CONCLUSION POPUP -->
  <div id="conclusionBackdrop" class="modal-backdrop hidden">
    <div class="conclusion-modal">
      <div class="conclusion-modal-header">
        <div class="conclusion-modal-title">Your SIP behaviour in this game</div>
        <button id="conclusionCloseBtn" class="conclusion-modal-close" aria-label="Close">Ã—</button>
      </div>
      <div class="conclusion-modal-body">
        <p id="conclusionLine1">
          You invested for <span class="conclusion-highlight">0 out of 60</span> months.
        </p>
        <ul class="conclusion-bullets">
          <li id="conclusionLine2">â€“</li>
          <li id="conclusionLine3">â€“</li>
          <li id="conclusionLine4">â€“</li>
        </ul>
        <p class="conclusion-note" id="conclusionNote">
          In real life, you can't draw the NAV path â€“ but you can control your SIP discipline.
        </p>
      </div>
      <div class="conclusion-modal-footer">
        <button id="conclusionPlayAgainBtn" class="conclusion-btn-secondary">
          ðŸŽ® Play again
        </button>
        <button id="conclusionSendBtn" class="conclusion-btn-primary">
          ðŸ“© Share (WhatsApp / Email)
        </button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast">SIP debit failed â€“ pointer lifted early!</div>

  <script>
    // BASIC CONFIG
    const TOTAL_MONTHS = 60;
    const MONTHLY_SIP = 10000;
    const GAME_DURATION_SECONDS = 30; // 30 sec game
    // Time gating: how many "months" of X-axis are unlocked per real second.
    const MONTHS_PER_SECOND = TOTAL_MONTHS / GAME_DURATION_SECONDS; // = 2 months/sec

    const MAX_INTERRUPTIONS = 3;
    const NAV_RANGE = 80; // approx 60..140 around 100

    // DOM ELEMENTS
    const canvas = document.getElementById("sipCanvas");
    const ctx = canvas.getContext("2d");
    const timerDisplay = document.getElementById("timerDisplay");
    const startBtn = document.getElementById("startBtn");
    const resetBtn = document.getElementById("resetBtn");
    const toast = document.getElementById("toast");
    const statusText = document.getElementById("statusText");
    const totalInvestedEl = document.getElementById("totalInvested");
    const currentMonthValueEl = document.getElementById("currentMonthValue");
    const currentMonthHeaderEl = document.getElementById("currentMonthHeader");
    const currentNavValueEl = document.getElementById("currentNavValue");
    const liveCorpusEl = document.getElementById("liveCorpus");
    const finalCorpusEl = document.getElementById("finalCorpusValue");
    const sipFailuresCountEl = document.getElementById("sipFailuresCount");
    const xirrValueEl = document.getElementById("xirrValue");
    const summaryScreenEl = document.getElementById("summaryScreen");
    const soundToggleBtn = document.getElementById("soundToggleBtn");
    const themeToggleBtn = document.getElementById("themeToggleBtn");

    // Summary elements
    const sumTotalInvestedEl = document.getElementById("sumTotalInvested");
    const sumFinalCorpusEl = document.getElementById("sumFinalCorpus");
    const sumIdealCorpusEl = document.getElementById("sumIdealCorpus");
    const sumInterruptionsEl = document.getElementById("sumInterruptions");
    const sumXirrEl = document.getElementById("sumXirr");
    const sumUnitsEl = document.getElementById("sumUnits");
    const sumAvgNavEl = document.getElementById("sumAvgNav");
    const behaviourTextEl = document.getElementById("behaviourText");
    const demoFundsListEl = document.getElementById("demoFundsList");

    // Share buttons
    const whatsappShareBtn = document.getElementById("whatsappShareBtn");
    const emailShareBtn = document.getElementById("emailShareBtn");

    // Conclusion modal elements
    const conclusionBackdrop = document.getElementById("conclusionBackdrop");
    const conclusionCloseBtn = document.getElementById("conclusionCloseBtn");
    const conclusionPlayAgainBtn = document.getElementById("conclusionPlayAgainBtn");
    const conclusionSendBtn = document.getElementById("conclusionSendBtn");
    const conclusionLine1 = document.getElementById("conclusionLine1");
    const conclusionLine2 = document.getElementById("conclusionLine2");
    const conclusionLine3 = document.getElementById("conclusionLine3");
    const conclusionLine4 = document.getElementById("conclusionLine4");
    const conclusionNote = document.getElementById("conclusionNote");

    // STATE
    let isDrawing = false;
    let gameActive = false;
    let points = []; // {x, y, month}
    let timerInterval = null;
    let remainingTime = GAME_DURATION_SECONDS;
    let canvasRect = null;
    let xMin, xMax, yMin, yMax;
    let sipFailures = 0;
    let lastPoint = null;

    // Blinking red dot state
    let interruptionPoints = []; // {x, y}
    let blinkOn = true;
    let blinkInterval = null;

    // Summary series (normalized 0..1)
    let summaryPlayerSeries = null;
    let summaryFundSeries = null;

    // Audio
    let audioCtx = null;
    let soundEnabled = true;
    let lastDrawSoundTime = 0;

    // Share payload (filled after game)
    let lastShareData = null;

    // Demo funds placeholder (static)
    const demoFunds = [
      { name: "Alpha Growth Fund", category: "Large Cap", xirr: "14.2%", navStart: 100, navEnd: 188 },
      { name: "Bluewave Equity Fund", category: "Multi Cap", xirr: "15.6%", navStart: 100, navEnd: 200 },
      { name: "SteadyCore Balanced", category: "Balanced", xirr: "11.3%", navStart: 100, navEnd: 170 },
      { name: "Momentum Midcap Fund", category: "Mid Cap", xirr: "17.8%", navStart: 100, navEnd: 215 },
      { name: "Vision Smallcap Fund", category: "Small Cap", xirr: "19.5%", navStart: 100, navEnd: 230 },
      { name: "Dividend Plus Value", category: "Value", xirr: "12.7%", navStart: 100, navEnd: 178 },
      { name: "Green Future ESG", category: "ESG / Thematic", xirr: "13.9%", navStart: 100, navEnd: 185 },
      { name: "WealthEdge FlexiCap", category: "Flexi Cap", xirr: "15.1%", navStart: 100, navEnd: 195 },
      { name: "Prime Index Fund", category: "Large Cap Index", xirr: "13.1%", navStart: 100, navEnd: 180 },
      { name: "Steady Income Hybrid", category: "Aggressive Hybrid", xirr: "10.4%", navStart: 100, navEnd: 160 }
    ];

    function renderDemoFunds() {
      if (!demoFundsListEl) return;
      demoFundsListEl.innerHTML = "";
      demoFunds.forEach(f => {
        const li = document.createElement("li");
        li.className = "demo-fund-item";
        li.innerHTML = `
          <span class="demo-fund-name">${f.name}</span>
          <span class="demo-fund-meta">${f.category} Â· XIRR ${f.xirr} Â· NAV ${f.navStart} â†’ ${f.navEnd}</span>
        `;
        demoFundsListEl.appendChild(li);
      });
    }

    // RESIZE MAIN CANVAS
    function resizeCanvas() {
      const parent = canvas.parentElement;
      const bounds = parent.getBoundingClientRect();
      const ratio = window.devicePixelRatio || 1;

      canvas.width = bounds.width * ratio;
      canvas.height = bounds.height * ratio;

      canvas.style.width = bounds.width + "px";
      canvas.style.height = bounds.height + "px";

      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);

      canvasRect = canvas.getBoundingClientRect();

      // Define drawing bounds with some padding
      xMin = 40;
      xMax = bounds.width - 20;
      yMin = 20;
      yMax = bounds.height - 30;

      drawBaseGrid();
      if (points.length > 0) {
        redrawCurve();
      }

      if (summaryPlayerSeries && summaryFundSeries && !summaryScreenEl.classList.contains("hidden")) {
        drawSummaryGraphs();
      }
    }

    window.addEventListener("resize", resizeCanvas);
    window.addEventListener("load", () => {
      resizeCanvas();
      renderDemoFunds();
      initThemeFromStorage();
    });

    // GRID
    function drawBaseGrid() {
      if (!canvasRect) return;
      const width = canvasRect.width;
      const height = canvasRect.height;

      ctx.clearRect(0, 0, width, height);

      const bgGrad = ctx.createLinearGradient(0, 0, width, height);
      bgGrad.addColorStop(0, "#021019");
      bgGrad.addColorStop(1, "#02070b");
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, width, height);

      ctx.save();
      ctx.strokeStyle = "#12313c";
      ctx.lineWidth = 1;

      for (let i = 0; i <= 6; i++) {
        const x = xMin + ((xMax - xMin) * i) / 6;
        ctx.beginPath();
        ctx.moveTo(x, yMin);
        ctx.lineTo(x, yMax);
        ctx.stroke();
      }

      for (let i = 0; i <= 4; i++) {
        const y = yMin + ((yMax - yMin) * i) / 4;
        ctx.beginPath();
        ctx.moveTo(xMin, y);
        ctx.lineTo(xMax, y);
        ctx.stroke();
      }

      ctx.strokeStyle = "#1f4c5b";
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.moveTo(xMin, yMax);
      ctx.lineTo(xMax, yMax);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(xMin, yMin);
      ctx.lineTo(xMin, yMax);
      ctx.stroke();

      ctx.fillStyle = "#7fa3b0";
      ctx.font = "10px system-ui";
      for (let m = 0; m <= TOTAL_MONTHS; m += 10) {
        const x = monthToX(m || 1);
        ctx.fillText(m.toString(), x - 6, yMax + 12);
      }

      ctx.restore();
    }

    // HELPERS
    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function monthToX(month) {
      if (month <= 1) return xMin;
      if (month >= TOTAL_MONTHS) return xMax;
      return xMin + ((xMax - xMin) * (month - 1)) / (TOTAL_MONTHS - 1);
    }

    function positionToMonth(x) {
      const ratio = (x - xMin) / (xMax - xMin);
      const month = 1 + ratio * (TOTAL_MONTHS - 1);
      return clamp(Math.round(month), 1, TOTAL_MONTHS);
    }

    function formatNumber(num) {
      return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }

    function formatPercent(rate) {
      if (rate === null || isNaN(rate)) return "â€“";
      return (rate * 100).toFixed(1) + "% p.a.";
    }

    function normalizedToNav(v) {
      const val = clamp(v, 0, 1);
      return 100 + (val - 0.5) * NAV_RANGE;
    }

    // Allowed month based on elapsed time
    function getAllowedMonth() {
      const elapsed = GAME_DURATION_SECONDS - remainingTime;
      let allowed = 1 + Math.floor(elapsed * MONTHS_PER_SECOND);
      if (allowed < 1) allowed = 1;
      if (allowed > TOTAL_MONTHS) allowed = TOTAL_MONTHS;
      return allowed;
    }

    // Build normalized 0..1 series for 1..maxMonth
    function buildNormalizedSeries(maxMonth) {
      if (maxMonth <= 0) return [];
      const series = new Array(maxMonth).fill(0.5);
      let lastVal = 0.5;

      for (let m = 1; m <= maxMonth; m++) {
        if (m === 1) {
          series[0] = 0.5;
          continue;
        }
        const ptsForMonth = points.filter(p => p.month === m);
        if (ptsForMonth.length > 0) {
          const p = ptsForMonth[ptsForMonth.length - 1];
          const normalized = 1 - (p.y - yMin) / (yMax - yMin);
          lastVal = clamp(normalized, 0, 1);
        }
        series[m - 1] = lastVal;
      }
      return series;
    }

    function updateLiveMetrics() {
      const currentMonth = lastPoint ? lastPoint.month : 0;
      currentMonthValueEl.textContent = `${currentMonth} / ${TOTAL_MONTHS}`;
      currentMonthHeaderEl.textContent = `${currentMonth} / ${TOTAL_MONTHS}`;

      if (currentMonth <= 0) {
        totalInvestedEl.textContent = "â‚¹0";
        liveCorpusEl.textContent = "â‚¹0";
        currentNavValueEl.textContent = "100.0";
        return;
      }

      const state = computeSipState(currentMonth);
      totalInvestedEl.textContent = "â‚¹" + formatNumber(state.invested);
      liveCorpusEl.textContent = "â‚¹" + formatNumber(Math.round(state.corpus));
      currentNavValueEl.textContent = state.nav.toFixed(1);
    }

    // SIP math
    function computeSipState(monthCount) {
      if (monthCount <= 0) {
        return { corpus: 0, nav: 100, units: 0, invested: 0, normSeries: [], navSeries: [] };
      }

      const normSeries = buildNormalizedSeries(monthCount);
      const navSeries = normSeries.map(normalizedToNav);

      let units = 0;
      let invested = 0;
      for (let i = 0; i < monthCount; i++) {
        invested += MONTHLY_SIP;
        units += MONTHLY_SIP / navSeries[i];
      }
      const finalNav = navSeries[monthCount - 1];
      const corpus = units * finalNav;

      return { corpus, nav: finalNav, units, invested, normSeries, navSeries };
    }

    // AUDIO
    function initAudio() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) {
          audioCtx = new AC();
        }
      }
    }

    function playBeep(freq, durationMs, gainValue) {
      if (!soundEnabled) return;
      if (!audioCtx) return;

      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = "sine";
      osc.frequency.setValueAtTime(freq, now);
      gain.gain.setValueAtTime(gainValue, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + durationMs / 1000);

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start(now);
      osc.stop(now + durationMs / 1000);
    }

    function playDrawSound() {
      if (!soundEnabled || !audioCtx) return;
      const now = performance.now();
      if (now - lastDrawSoundTime < 120) return;
      lastDrawSoundTime = now;
      playBeep(700, 40, 0.01);
    }

    function playSipFailSound() {
      if (!soundEnabled || !audioCtx) return;
      playBeep(260, 160, 0.03);
    }

    function playGameEndSound() {
      if (!soundEnabled || !audioCtx) return;
      playBeep(440, 100, 0.02);
      setTimeout(() => playBeep(660, 120, 0.02), 120);
    }

    // DRAWING â€“ time-gated months
    function startDrawingPointer(evt) {
      if (!gameActive || !canvasRect) return;
      evt.preventDefault();
      initAudio();

      const rawY = evt.clientY - canvasRect.top;
      const y = clamp(rawY, yMin, yMax);

      const allowedMonth = getAllowedMonth();

      if (points.length === 0) {
        // Must start at month 1
        const month = 1;
        const x = monthToX(month);
        const startPoint = { x, y, month };
        points.push(startPoint);
        lastPoint = startPoint;
        isDrawing = true;
        statusText.textContent = "Drawing â€“ time is your X-axis now";
        redrawCurve();
        updateLiveMetrics();
        playDrawSound();
        return;
      }

      const prev = lastPoint;
      let month = Math.max(prev.month, allowedMonth);
      if (month > TOTAL_MONTHS) month = TOTAL_MONTHS;
      const x = monthToX(month);

      const resumedPoint = { x, y, month };
      points.push(resumedPoint);
      lastPoint = resumedPoint;
      isDrawing = true;
      redrawCurve();
      updateLiveMetrics();
      playDrawSound();
    }

    function moveDrawingPointer(evt) {
      if (!isDrawing || !gameActive || !canvasRect) return;
      evt.preventDefault();

      const rawY = evt.clientY - canvasRect.top;
      const y = clamp(rawY, yMin, yMax);

      const allowedMonth = getAllowedMonth();
      if (!lastPoint) return;

      const rawX = evt.clientX - canvasRect.left;
      let desiredMonth = positionToMonth(rawX);
      let month = Math.min(desiredMonth, allowedMonth);
      month = Math.max(month, lastPoint.month); // never go backwards
      if (month > TOTAL_MONTHS) month = TOTAL_MONTHS;

      const x = monthToX(month);
      const newPoint = { x, y, month };
      points.push(newPoint);
      lastPoint = newPoint;
      redrawCurve();
      updateLiveMetrics();
      playDrawSound();
    }

    function stopDrawingPointer(evt) {
      if (!isDrawing) return;
      evt && evt.preventDefault();
      isDrawing = false;

      if (!lastPoint || !gameActive) return;

      const finalMonthReached = lastPoint.month >= TOTAL_MONTHS - 1;
      if (!finalMonthReached) {
        sipFailures++;
        sipFailuresCountEl.textContent = sipFailures.toString();

        if (interruptionPoints.length < MAX_INTERRUPTIONS) {
          interruptionPoints.push({ x: lastPoint.x, y: lastPoint.y });
          showToast("SIP debit failed â€“ pointer lifted early!");
          statusText.textContent = "SIP interrupted â€“ you can resume from this point.";
          redrawCurve();
          playSipFailSound();
        } else {
          showToast("Maximum SIP interruptions reached â€“ game over.");
          playSipFailSound();
          endGame();
        }
      }
    }

    // REDRAW
    function redrawCurve() {
      drawBaseGrid();

      if (points.length >= 2) {
        ctx.save();
        ctx.strokeStyle = "#3bd88f";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();
        ctx.restore();
      }

      if (interruptionPoints.length > 0 && blinkOn) {
        ctx.save();
        ctx.strokeStyle = "#ff4b5c";
        ctx.fillStyle = "rgba(255, 75, 92, 0.2)";
        ctx.lineWidth = 2;

        interruptionPoints.forEach((pt) => {
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          ctx.beginPath();
          ctx.fillStyle = "#ff4b5c";
          ctx.arc(pt.x, pt.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.restore();
      }
    }

    // TIMER
    function startTimer() {
      remainingTime = GAME_DURATION_SECONDS;
      timerDisplay.textContent = remainingTime + "s";

      timerInterval = setInterval(() => {
        remainingTime--;
        if (remainingTime < 0) remainingTime = 0;
        timerDisplay.textContent = remainingTime + "s";

        const allowedMonth = getAllowedMonth();
        currentMonthHeaderEl.textContent = `${allowedMonth} / ${TOTAL_MONTHS}`;

        if (remainingTime <= 0) {
          endGame();
        }
      }, 1000);
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    // BLINKING
    function startBlinking() {
      if (blinkInterval) clearInterval(blinkInterval);
      blinkOn = true;
      blinkInterval = setInterval(() => {
        blinkOn = !blinkOn;
        redrawCurve();
      }, 500);
    }

    function stopBlinking() {
      if (blinkInterval) {
        clearInterval(blinkInterval);
        blinkInterval = null;
      }
    }

    // XIRR
    function computeXIRR(cashflows, dates) {
      if (!cashflows || cashflows.length === 0) return null;

      const maxIter = 100;
      const tol = 1e-6;
      const dayMs = 24 * 60 * 60 * 1000;
      const d0 = dates[0];

      function f(rate) {
        let sum = 0;
        for (let i = 0; i < cashflows.length; i++) {
          const t = (dates[i] - d0) / dayMs / 365.0;
          sum += cashflows[i] / Math.pow(1 + rate, t);
        }
        return sum;
      }

      function fPrime(rate) {
        let sum = 0;
        for (let i = 0; i < cashflows.length; i++) {
          const t = (dates[i] - d0) / dayMs / 365.0;
          sum += (-t * cashflows[i]) / Math.pow(1 + rate, t + 1);
        }
        return sum;
      }

      let rate = 0.12;
      for (let iter = 0; iter < maxIter; iter++) {
        const y = f(rate);
        const yprime = fPrime(rate);
        if (Math.abs(yprime) < 1e-10) break;
        const newRate = rate - y / yprime;
        if (!isFinite(newRate)) break;
        if (Math.abs(newRate - rate) < tol) {
          return newRate;
        }
        rate = newRate;
      }

      return rate;
    }

    // GAME CONTROL
    function startGame() {
      initAudio();
      gameActive = true;
      points = [];
      lastPoint = null;
      sipFailures = 0;
      interruptionPoints = [];
      sipFailuresCountEl.textContent = "0";
      finalCorpusEl.textContent = "â€“";
      xirrValueEl.textContent = "â€“";
      statusText.textContent = "Drawing â€“ time is your X-axis now";
      startBtn.disabled = true;
      resetBtn.disabled = false;
      remainingTime = GAME_DURATION_SECONDS;
      timerDisplay.textContent = remainingTime + "s";
      currentMonthValueEl.textContent = `0 / ${TOTAL_MONTHS}`;
      currentMonthHeaderEl.textContent = `0 / ${TOTAL_MONTHS}`;
      totalInvestedEl.textContent = "â‚¹0";
      liveCorpusEl.textContent = "â‚¹0";
      currentNavValueEl.textContent = "100.0";

      summaryScreenEl.classList.add("hidden");
      summaryPlayerSeries = null;
      summaryFundSeries = null;
      lastShareData = null;
      closeConclusionModal();

      drawBaseGrid();
      startTimer();
      startBlinking();
    }

    function endGame() {
      if (!gameActive) return;
      gameActive = false;
      isDrawing = false;
      stopTimer();
      timerDisplay.textContent = "0s";
      statusText.textContent = "Game over â€“ calculating your SIP journey...";
      stopBlinking();
      playGameEndSound();

      computeResults();
      startBtn.disabled = false;
    }

    function resetGame() {
      stopTimer();
      stopBlinking();
      gameActive = false;
      isDrawing = false;
      points = [];
      lastPoint = null;
      sipFailures = 0;
      interruptionPoints = [];
      sipFailuresCountEl.textContent = "0";
      remainingTime = GAME_DURATION_SECONDS;
      timerDisplay.textContent = remainingTime + "s";
      statusText.textContent = "Idle â€“ press Start";
      startBtn.disabled = false;
      resetBtn.disabled = true;
      finalCorpusEl.textContent = "â€“";
      xirrValueEl.textContent = "â€“";
      currentMonthValueEl.textContent = `0 / ${TOTAL_MONTHS}`;
      currentMonthHeaderEl.textContent = `0 / ${TOTAL_MONTHS}`;
      totalInvestedEl.textContent = "â‚¹0";
      liveCorpusEl.textContent = "â‚¹0";
      currentNavValueEl.textContent = "100.0";

      summaryScreenEl.classList.add("hidden");
      summaryPlayerSeries = null;
      summaryFundSeries = null;
      lastShareData = null;
      closeConclusionModal();

      drawBaseGrid();
    }

    function computeResults() {
      if (!lastPoint || points.length === 0) {
        finalCorpusEl.textContent = "No curve drawn";
        return;
      }

      const monthsUsed = lastPoint.month;
      const state = computeSipState(monthsUsed);
      const live = state.corpus;
      finalCorpusEl.textContent = "â‚¹" + formatNumber(Math.round(live));

      const penaltyFactor = 1 - Math.min(sipFailures * 0.05, 0.4);
      const idealCorpus = penaltyFactor < 1 ? live / penaltyFactor : live;

      const cashflows = [];
      const dates = [];
      const baseDate = new Date(2020, 0, 1);
      for (let m = 0; m < monthsUsed; m++) {
        cashflows.push(-MONTHLY_SIP);
        dates.push(new Date(baseDate.getFullYear(), baseDate.getMonth() + m, 1));
      }
      cashflows.push(live);
      dates.push(new Date(baseDate.getFullYear(), baseDate.getMonth() + monthsUsed - 1, 28));

      const xirrRate = computeXIRR(cashflows, dates);
      const xirrDisplay = formatPercent(xirrRate);
      xirrValueEl.textContent = xirrDisplay;

      buildSummarySeriesFromPoints();

      const avgNav = state.units > 0 ? state.invested / state.units : 0;
      showSummary(live, idealCorpus, xirrRate, state.units, avgNav, state.navSeries);
    }

    // SUMMARY SERIES
    function buildSummarySeriesFromPoints() {
      const series = buildNormalizedSeries(TOTAL_MONTHS);
      summaryPlayerSeries = series;

      const fundSeries = [];
      for (let i = 0; i < TOTAL_MONTHS; i++) {
        const t = i / (TOTAL_MONTHS - 1);
        const idealUp = 0.2 + 0.6 * t;
        const blended = 0.4 * series[i] + 0.6 * idealUp;
        fundSeries.push(clamp(blended, 0, 1));
      }
      summaryFundSeries = fundSeries;
    }

    // SUMMARY DISPLAY
    function showSummary(liveCorpus, idealCorpus, xirrRate, units, avgNav, navSeries) {
      const monthsUsed = lastPoint ? lastPoint.month : TOTAL_MONTHS;
      const totalInvested = monthsUsed * MONTHLY_SIP;

      sumTotalInvestedEl.textContent = "â‚¹" + formatNumber(totalInvested);
      sumFinalCorpusEl.textContent = "â‚¹" + formatNumber(Math.round(liveCorpus));
      sumIdealCorpusEl.textContent = "â‚¹" + formatNumber(Math.round(idealCorpus));
      sumInterruptionsEl.textContent = sipFailures.toString();
      sumXirrEl.textContent = formatPercent(xirrRate);
      sumUnitsEl.textContent = units > 0 ? units.toFixed(2) : "â€“";
      sumAvgNavEl.textContent = units > 0 ? avgNav.toFixed(2) : "â€“";

      let monthsBelow100 = 0;
      let monthsAbove100 = 0;
      if (navSeries && navSeries.length) {
        navSeries.forEach(n => {
          if (n < 100) monthsBelow100++;
          else if (n > 100) monthsAbove100++;
        });
      }

      const dipsText = monthsBelow100 > 0
        ? `In about ${monthsBelow100} month(s), NAV dipped below 100, so your SIP was buying more units at lower prices. `
        : `Your NAV stayed mostly around or above 100, so you had fewer chances to buy extra cheap units. `;

      const ralliesText = monthsAbove100 > 0
        ? `Later, NAV moved above 100 in ${monthsAbove100} month(s), so those accumulated units grew in value.`
        : `There were limited strong rallies above 100, so the compounding jumps were smaller.`;

      let sipBreakText = "";
      if (sipFailures === 0) {
        sipBreakText = " You also kept all SIPs running without breaks â€“ perfect discipline.";
      } else {
        sipBreakText = ` You had ${sipFailures} SIP break(s); in real investing, fewer breaks give compounding more power.`;
      }

      behaviourTextEl.textContent = dipsText + ralliesText + sipBreakText;

      const finalNav =
        navSeries && navSeries.length ? navSeries[navSeries.length - 1] : null;

      summaryScreenEl.classList.remove("hidden");
      drawSummaryGraphs();

      // Prepare data for share
      lastShareData = {
        monthsUsed,
        totalInvested,
        liveCorpus,
        idealCorpus,
        xirrRate,
        sipFailures
      };

      // 2s delay before conclusion popup
      setTimeout(() => {
        openConclusionModal({
          monthsUsed,
          sipFailures,
          units,
          avgNav,
          finalNav,
          xirrRate,
          monthsBelow100,
          monthsAbove100
        });
      }, 2000);
    }

    // SUMMARY GRAPHS
    function drawSummaryGraphs() {
      drawSeriesOnCanvas("playerCurveSummary", summaryPlayerSeries, "#3bd88f", "Your NAV");
      drawSeriesOnCanvas("fundCurveSummary", summaryFundSeries, "#4da3ff", "Fund NAV");
    }

    function drawSeriesOnCanvas(canvasId, series, strokeStyle, labelPrefix) {
      const c = document.getElementById(canvasId);
      if (!c || !series || series.length < 2) return;

      const parent = c.parentElement;
      const rect = parent.getBoundingClientRect();
      const ratio = window.devicePixelRatio || 1;
      const width = rect.width;
      const height = 180;

      c.width = width * ratio;
      c.height = height * ratio;
      c.style.width = width + "px";
      c.style.height = height + "px";

      const cctx = c.getContext("2d");
      cctx.setTransform(ratio, 0, 0, ratio, 0, 0);

      cctx.fillStyle = "#02070b";
      cctx.fillRect(0, 0, width, height);

      const leftPad = 32;
      const rightPad = 10;
      const topPad = 10;
      const bottomPad = 18;
      const usableW = width - leftPad - rightPad;
      const usableH = height - topPad - bottomPad;

      const navMax = 100 + NAV_RANGE / 2;
      const navMin = 100 - NAV_RANGE / 2;

      cctx.strokeStyle = "#12242c";
      cctx.lineWidth = 1;
      cctx.font = "10px system-ui";
      cctx.fillStyle = "#7fa3b0";

      const steps = 4;
      for (let i = 0; i <= steps; i++) {
        const y = topPad + (usableH * i) / steps;
        cctx.beginPath();
        cctx.moveTo(leftPad, y);
        cctx.lineTo(width - rightPad, y);
        cctx.stroke();

        const navValue = navMax - (navMax - navMin) * (i / steps);
        cctx.fillText(Math.round(navValue).toString(), 4, y + 3);
      }

      cctx.strokeStyle = "#1f4c5b";
      cctx.lineWidth = 1.5;
      cctx.beginPath();
      cctx.moveTo(leftPad, topPad + usableH);
      cctx.lineTo(width - rightPad, topPad + usableH);
      cctx.stroke();

      cctx.strokeStyle = strokeStyle;
      cctx.lineWidth = 2;
      cctx.beginPath();

      const navSeries = [];
      series.forEach((value, idx) => {
        const x = leftPad + (usableW * idx) / (series.length - 1);
        const val = clamp(value, 0, 1);
        const y = topPad + (1 - val) * usableH;
        const navVal = normalizedToNav(val);
        navSeries.push({ x, y, nav: navVal });
        if (idx === 0) cctx.moveTo(x, y);
        else cctx.lineTo(x, y);
      });
      cctx.stroke();

      const last = navSeries[navSeries.length - 1];
      if (last) {
        cctx.fillStyle = strokeStyle;
        cctx.beginPath();
        cctx.arc(last.x, last.y, 3, 0, Math.PI * 2);
        cctx.fill();

        cctx.fillStyle = "#e3f6ff";
        cctx.font = "10px system-ui";
        const label = `${labelPrefix}: NAV ${last.nav.toFixed(1)}`;
        const labelX = Math.min(last.x + 6, width - rightPad - 110);
        const labelY = Math.max(last.y - 6, topPad + 12);
        cctx.fillText(label, labelX, labelY);
      }
    }

    // CONCLUSION MODAL
    function openConclusionModal(params) {
      const {
        monthsUsed,
        sipFailures,
        units,
        avgNav,
        finalNav,
        xirrRate,
        monthsBelow100,
        monthsAbove100
      } = params;

      conclusionLine1.innerHTML =
        `You invested for <span class="conclusion-highlight">${monthsUsed} out of 60</span> months.`;

      if (sipFailures === 0) {
        conclusionLine2.textContent =
          "You kept every SIP running without any breaks â€“ perfect discipline for compounding.";
      } else if (sipFailures === 1) {
        conclusionLine2.textContent =
          "You had 1 SIP break; in real investing, even one missed SIP slightly reduces the compounding effect.";
      } else {
        conclusionLine2.textContent =
          `You had ${sipFailures} SIP breaks; too many breaks can reduce the benefit of compounding over time.`;
      }

      let dipsText = "";
      if (monthsBelow100 > 0) {
        dipsText =
          `NAV went below 100 in about ${monthsBelow100} month(s), so your SIP was buying more units at lower prices. `;
      } else {
        dipsText =
          "Your NAV stayed mostly around or above 100, so you had fewer chances to buy extra cheap units. ";
      }

      let ralliesText = "";
      if (monthsAbove100 > 0) {
        ralliesText =
          `Later, NAV moved above 100 in ${monthsAbove100} month(s), so those accumulated units grew in value.`;
      } else {
        ralliesText =
          "There were limited strong rallies above 100, so the compounding jumps were smaller.";
      }
      conclusionLine3.textContent = dipsText + ralliesText;

      if (units && avgNav && finalNav) {
        const avgNavTxt = avgNav.toFixed(2);
        const finalNavTxt = finalNav.toFixed(2);
        const xirrTxt =
          xirrRate != null && isFinite(xirrRate) ? (xirrRate * 100).toFixed(1) + "% p.a. (illustrative)" : "â€“";
        conclusionLine4.textContent =
          `You accumulated about ${units.toFixed(2)} units at an average buy NAV of â‚¹${avgNavTxt}, ` +
          `ending at NAV ~â‚¹${finalNavTxt} with an XIRR of ${xirrTxt}.`;
      } else {
        conclusionLine4.textContent =
          "Your SIP accumulated units over time and turned into a corpus based on how the NAV moved.";
      }

      conclusionNote.textContent =
        "In real life, you can't control the NAV path â€“ but you can control your SIP discipline and stay invested through dips and recoveries.";

      conclusionBackdrop.classList.remove("hidden");
    }

    function closeConclusionModal() {
      conclusionBackdrop.classList.add("hidden");
    }

    // TOAST
    function showToast(message) {
      toast.textContent = message;
      toast.classList.add("show");
      setTimeout(() => {
        toast.classList.remove("show");
      }, 2000);
    }

    // THEME TOGGLE
    function initThemeFromStorage() {
      const saved = localStorage.getItem("sipCurveTheme");
      if (saved === "light") {
        document.body.classList.add("light-theme");
        themeToggleBtn.textContent = "â˜€ï¸ Light";
      } else {
        document.body.classList.remove("light-theme");
        themeToggleBtn.textContent = "ðŸŒ™ Dark";
      }
    }

    if (themeToggleBtn) {
      themeToggleBtn.addEventListener("click", () => {
        document.body.classList.toggle("light-theme");
        const isLight = document.body.classList.contains("light-theme");
        themeToggleBtn.textContent = isLight ? "â˜€ï¸ Light" : "ðŸŒ™ Dark";
        localStorage.setItem("sipCurveTheme", isLight ? "light" : "dark");
      });
    }

    // SOUND TOGGLE
    if (soundToggleBtn) {
      soundToggleBtn.addEventListener("click", () => {
        soundEnabled = !soundEnabled;
        soundToggleBtn.textContent = soundEnabled ? "ðŸ”Š Sound: On" : "ðŸ”ˆ Sound: Off";
      });
    }

    // SHARE HELPERS
    function buildShareText() {
      if (!lastShareData) {
        return "I just tried the SIP Curve Challenge (compounding demo).";
      }
      const {
        monthsUsed,
        totalInvested,
        liveCorpus,
        idealCorpus,
        xirrRate,
        sipFailures
      } = lastShareData;

      const xirrText =
        xirrRate != null && isFinite(xirrRate) ? (xirrRate * 100).toFixed(1) + "% p.a. (illustrative)" : "â€“";

      const lines = [
        "I just played the SIP Curve Challenge (power of compounding demo)!",
        "",
        `Months invested in game: ${monthsUsed} / 60`,
        `Total invested (demo): â‚¹${formatNumber(totalInvested)}`,
        `Final corpus from my curve (demo): â‚¹${formatNumber(Math.round(liveCorpus))}`,
        `Ideal corpus without SIP breaks (demo): â‚¹${formatNumber(Math.round(idealCorpus))}`,
        `SIP interruptions in the game: ${sipFailures}`,
        `XIRR based on my curve (illustrative): ${xirrText}`,
        "",
        "The game shows how buying more units when NAV is low and staying invested through recoveries gives compounding power.",
        "",
        "Try drawing your own curve and see how your SIP discipline changes the outcome!"
      ];

      return lines.join("\n");
    }

    function shareOnWhatsApp() {
      if (!lastShareData) {
        showToast("Play one full game to generate a result to share.");
        return;
      }
      const text = encodeURIComponent(buildShareText());
      const url = `https://wa.me/?text=${text}`;
      window.open(url, "_blank");
    }

    function shareByEmail() {
      if (!lastShareData) {
        showToast("Play one full game to generate a result to share.");
        return;
      }
      const subject = encodeURIComponent("My SIP Curve Challenge result (demo)");
      const body = encodeURIComponent(buildShareText());
      window.location.href = `mailto:?subject=${subject}&body=${body}`;
    }

    // POINTER EVENTS
    canvas.addEventListener("pointerdown", startDrawingPointer);
    canvas.addEventListener("pointermove", moveDrawingPointer);
    canvas.addEventListener("pointerup", stopDrawingPointer);
    canvas.addEventListener("pointercancel", stopDrawingPointer);
    window.addEventListener("pointerup", stopDrawingPointer);

    // BUTTONS
    startBtn.addEventListener("click", startGame);
    resetBtn.addEventListener("click", resetGame);

    // Share buttons
    if (whatsappShareBtn) {
      whatsappShareBtn.addEventListener("click", shareOnWhatsApp);
    }
    if (emailShareBtn) {
      emailShareBtn.addEventListener("click", shareByEmail);
    }

    // Modal events
    if (conclusionCloseBtn) {
      conclusionCloseBtn.addEventListener("click", closeConclusionModal);
    }
    if (conclusionBackdrop) {
      conclusionBackdrop.addEventListener("click", (e) => {
        if (e.target === conclusionBackdrop) {
          closeConclusionModal();
        }
      });
    }
    if (conclusionPlayAgainBtn) {
      conclusionPlayAgainBtn.addEventListener("click", () => {
        closeConclusionModal();
        resetGame();
        startGame();
      });
    }
    if (conclusionSendBtn) {
      conclusionSendBtn.addEventListener("click", () => {
        if (!lastShareData) {
          showToast("Play one full game to generate a result to share.");
          return;
        }
        const useWhatsApp = confirm("OK = Share on WhatsApp, Cancel = Share via Email");
        if (useWhatsApp) {
          shareOnWhatsApp();
        } else {
          shareByEmail();
        }
      });
    }
  </script>
</body>
</html>
